<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>数学 on 疏间徒泍の旅途</title>
        <link>https://SJTdreams.github.io/tags/%E6%95%B0%E5%AD%A6/</link>
        <description>Recent content in 数学 on 疏间徒泍の旅途</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>疏间徒泍</copyright>
        <lastBuildDate>Thu, 05 Jun 2025 08:13:34 +0800</lastBuildDate><atom:link href="https://SJTdreams.github.io/tags/%E6%95%B0%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>一种有趣的数学构筑尝试</title>
        <link>https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/</link>
        <pubDate>Wed, 04 Jun 2025 00:00:00 +0000</pubDate>
        
        <guid>https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/</guid>
        <description>&lt;img src="https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/title.png" alt="Featured image of post 一种有趣的数学构筑尝试" /&gt;&lt;h1 id=&#34;一种有趣的数学构筑法&#34;&gt;一种有趣的数学构筑法
&lt;/h1&gt;&lt;h1 id=&#34;一引言&#34;&gt;一、引言
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在看到某些分段函数时，其中所蕴含的一种“不够直接”的感觉往往令我感到难受。我们是否能找到一种方式，来用任意一个函数拟合各种特别的分段函数呢？&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在必修一的课本上，存在这样一幅函数图像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/image1.PNG&#34;
	width=&#34;714&#34;
	height=&#34;223&#34;
	srcset=&#34;https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/image1_hu_d2cee8ced6336d20.PNG 480w, https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/image1_hu_972c76ae32e404d7.PNG 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;320&#34;
		data-flex-basis=&#34;768px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;​	课本上对于该函数的表达式为：&lt;/p&gt;
$$
y=\left|x-2k\right|\left(2k-1&lt;x&lt;2k+1\right)\left(k∈Z\right)
$$&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;然而，当我们尝试直接在&lt;strong&gt;desmos&lt;/strong&gt;中使用这个公式时，我们会遇到这样的问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/image2.PNG&#34;
	width=&#34;447&#34;
	height=&#34;80&#34;
	srcset=&#34;https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/image2_hu_393f19cde03b419d.PNG 480w, https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/image2_hu_5913f80fb770f95e.PNG 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;558&#34;
		data-flex-basis=&#34;1341px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;​	让我们来考虑一个问题：&lt;strong&gt;能否不用这种带括号指定范围的分段函数，来实现相同的效果&lt;/strong&gt;呢？&lt;/p&gt;
&lt;p&gt;​	先看结论！这个函数，写成&lt;strong&gt;这样子&lt;/strong&gt;（可以复制到desmos里尝试）：
&lt;/p&gt;
$$
y = \left(\left(-1\right)^{1+\lceil x \rceil} \cdot \text{mod}\left(x, 1\right)\right) + \left(\text{mod}\left(\lfloor x \rfloor, 2\right)\right)
$$&lt;p&gt;
看上去相当的复杂，对吧？在介绍原理之前，我们可以再举一个例子：统计学的&lt;strong&gt;百分位数&lt;/strong&gt;。
&lt;/p&gt;
$$
P_k = 
\begin{cases} 
x_{\lfloor n \cdot k \rfloor + 1}, &amp; \text{如果 } n \cdot k \text{ 不是整数} \\
\frac{x_{n \cdot k} + x_{n \cdot k + 1}}{2}, &amp; \text{如果 } n \cdot k \text{ 是整数}
\end{cases}
$$&lt;p&gt;
这是它的常规公式。那么，我们能否找到一个&lt;strong&gt;独立&lt;/strong&gt;的公式，效果却和百分位数&lt;strong&gt;一模一样&lt;/strong&gt;呢？有的兄弟，有的！先看结论：
&lt;/p&gt;
$$
t = \left( \frac{\lceil | n \times k\% - \lfloor n \times k\% \rfloor | \rceil + 1}{2} \right) \times X_{\lceil n \times k\% \rceil} + \left( \frac{|\lceil \text{mod}(n \times k\%, 1) \rceil - 1|}{2} \right) \times X_{\lceil n \times k\% \rceil + 1}
$$&lt;p&gt;
看上去似乎更加复杂了&amp;hellip;那么，我们要如何写出这样的函数呢？让我们先来拆分下上面两个函数的思路！&lt;/p&gt;
&lt;h1 id=&#34;二逻辑拆分&#34;&gt;二、逻辑拆分
&lt;/h1&gt;&lt;p&gt;尽管以上两个公式令人生畏，但其中包含一个清晰的逻辑。让我们对其进行具体分析：&lt;/p&gt;
&lt;h2 id=&#34;1锯齿函数&#34;&gt;1.锯齿函数
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/image1.PNG&#34;
	width=&#34;714&#34;
	height=&#34;223&#34;
	srcset=&#34;https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/image1_hu_d2cee8ced6336d20.PNG 480w, https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/image1_hu_972c76ae32e404d7.PNG 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;320&#34;
		data-flex-basis=&#34;768px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;观察原图像，我们可以分析一下其具备的规律：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在所有的&lt;strong&gt;偶数到奇数&lt;/strong&gt;段内，曲线从&lt;code&gt;0 - 1&lt;/code&gt;上升。&lt;/li&gt;
&lt;li&gt;在所有的&lt;strong&gt;奇数到偶数&lt;/strong&gt;段内，曲线从&lt;code&gt;1 - 0&lt;/code&gt;下降。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;规则很简单，我们要如何着手这个图像呢？既然我们不打算用括号显式的指定&lt;strong&gt;周期函数&lt;/strong&gt;，那我们不妨用些现成的周期函数。观察&lt;code&gt;mod(x,1)&lt;/code&gt;的图像，我们会发现，这和我们的目标很相似：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/image3.PNG&#34;
	width=&#34;1439&#34;
	height=&#34;735&#34;
	srcset=&#34;https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/image3_hu_c001e43574076636.PNG 480w, https://SJTdreams.github.io/p/%E4%B8%80%E7%A7%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%9E%84%E7%AD%91%E5%B0%9D%E8%AF%95/image3_hu_ad0b2b11eab1ee51.PNG 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;195&#34;
		data-flex-basis=&#34;469px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;很显然，这个图像在所有的&lt;strong&gt;偶数到奇数&lt;/strong&gt;段完全正确！因此，我们要做的就是把偶数段和奇数段分开处理。怎么做到呢？&lt;/p&gt;
&lt;p&gt;这里我们不妨看看另一个函数：&lt;code&gt;-1^n&lt;/code&gt;。我们都知道，&lt;strong&gt;-1&lt;/strong&gt;的&lt;strong&gt;奇数次幂&lt;/strong&gt;为-1，&lt;strong&gt;偶数次幂&lt;/strong&gt;为1。刚好，我们需要做到的效果是偶数次幂时方向取反。将&lt;strong&gt;偶数到奇数&lt;/strong&gt;区段内的数进行&lt;strong&gt;向上取整&lt;/strong&gt;会使其变成奇数，反之亦然。在这么做之后多取一个**-1**就可以达到效果！（其实直接向下取整也可以）&lt;/p&gt;
&lt;p&gt;那么，我们就得到了第二个关键组件：
&lt;/p&gt;
$$
\left(-1\right)^{1+\lceil x \rceil}
$$&lt;p&gt;
&lt;img src=&#34;image4.PNG&#34; alt=&#34;image1&#34; style=&#34;zoom:75%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所得图像如下。&lt;/p&gt;
&lt;p&gt;接下来我们要将所有的&lt;strong&gt;偶数&lt;/strong&gt;（奇数到偶数）区段+1。简单用一个取模函数加上向下取整即可：
&lt;/p&gt;
$$
\left(\text{mod}\left(\lfloor x \rfloor, 2\right)\right)
$$&lt;p&gt;
那么，只要将这三个模块组合，就可以达到完整的函数效果。接下来，让我们分析一下第二个函数：&lt;/p&gt;
&lt;h2 id=&#34;2百分位数&#34;&gt;2.百分位数
&lt;/h2&gt;&lt;p&gt;让我们先观察一下百分位数的逻辑：
&lt;/p&gt;
$$
P_k = 
\begin{cases} 
x_{\lfloor n \cdot k \rfloor + 1}, &amp; \text{如果 } n \cdot k \text{ 不是整数} \\
\frac{x_{n \cdot k} + x_{n \cdot k + 1}}{2}, &amp; \text{如果 } n \cdot k \text{ 是整数}
\end{cases}
$$&lt;p&gt;
为了让式子尽可能的简单，我们来看看存在哪些点可以简化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，当&lt;code&gt;n*k&lt;/code&gt;不是整数的时候，对其进行向下取整再加一完全可以等价于向上取整；&lt;/li&gt;
&lt;li&gt;如果&lt;em&gt;n*k&lt;/em&gt;是整数，n*k的向上取整值不变&lt;/li&gt;
&lt;li&gt;那么，我们可以把逻辑简化为：一定会取一半的当前位数（指n*k向上取整位置）；如果是整数，就取一半下一位数的值；如果不是，则再取一半当前位数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再完成这样的分析后，再来写式子就简单多了。&lt;/p&gt;
&lt;p&gt;首先，我们肯定需要一个基底的一半当前位数：
&lt;/p&gt;
$$
t = \frac{1}{2} \times X_{\lceil n \times k\% \rceil}
$$&lt;p&gt;
接下来，我们需要得到一个式子用来判断是否具备小数。有两个简单的式子可以达到这个目的：
&lt;/p&gt;
$$
\lceil x-\lfloor x \rfloor\rceil  \\  \lceil mod(x,1) \rceil
$$&lt;p&gt;
这两个式子具备相同的效果，具体情况是：&lt;strong&gt;在有小数时输出&lt;code&gt;1&lt;/code&gt;，否则输出&lt;code&gt;0&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们只要用这个式子的结果乘以一半的&lt;strong&gt;当前位数&lt;/strong&gt;的值，再拿式子的结果相反值乘以一半的&lt;strong&gt;下一位数&lt;/strong&gt;的值，就可以达成目的了。那么，我们还需要一个取反的式子：
&lt;/p&gt;
$$
-(x-1)  \\ |x-1|
$$&lt;p&gt;
这两个式子都可以达成完全相同的效果。那么，我们只要把数个模块组装起来，就可以得到最终式子：
&lt;/p&gt;
$$
t = \left( \frac{\lceil | n \times k\% - \lfloor n \times k\% \rfloor | \rceil + 1}{2} \right) \times X_{\lceil n \times k\% \rceil} + \left( \frac{|\lceil \text{mod}(n \times k\%, 1) \rceil - 1|}{2} \right) \times X_{\lceil n \times k\% \rceil + 1}
$$&lt;h2 id=&#34;3思考范式&#34;&gt;3.思考范式
&lt;/h2&gt;&lt;p&gt;通过以上两个例子，我们可以注意到，这种方式可以找到一个共通的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分析原式&lt;/li&gt;
&lt;li&gt;找到规律&lt;/li&gt;
&lt;li&gt;找出式子&lt;/li&gt;
&lt;li&gt;组合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分析原式和找到规律的部分似乎没有什么好用的快速方案，然而，式子中却似乎有很多部分是共通的！那么，我们不妨对常用的式子进行一个提取？&lt;/p&gt;
&lt;h1 id=&#34;三公式逻辑门&#34;&gt;三、公式逻辑门
&lt;/h1&gt;&lt;p&gt;为了更好的运用这些公式进行组装，我们不妨采取一个&lt;strong&gt;统一的接口数字&lt;/strong&gt;。那么，我们不妨设为&lt;code&gt;0和1&lt;/code&gt;。其中，&lt;strong&gt;1&lt;/strong&gt;代表&lt;strong&gt;是&lt;/strong&gt;，0代表&lt;strong&gt;否&lt;/strong&gt;！同时，为了方便，我们可以再取&lt;code&gt;1和-1&lt;/code&gt;作为第二套逻辑标准。&lt;/p&gt;
&lt;h2 id=&#34;单位转化&#34;&gt;单位转化
&lt;/h2&gt;&lt;p&gt;那么，当务之急就是先定义出两套标准的转化。我们不妨让0和-1互相转化：
&lt;/p&gt;
$$
1,0 =&gt; 1,-1 : -(-1)^x \\ 1,0 &lt;= 1,-1 :\frac{x+1}{2}
$$&lt;p&gt;
这两串有趣的式子就可以在x值合适的情况下完成转换的工作！接下来，我们再定义出几个有趣的小工具。&lt;/p&gt;
&lt;h2 id=&#34;符号提取&#34;&gt;符号提取
&lt;/h2&gt;&lt;p&gt;符号提取可以将一个大小任意的数字转化到标准信号的一种之中。我们可以很自然的想到这样的方式：
&lt;/p&gt;
$$
\frac{x}{|x|}
$$&lt;p&gt;
然而，这个式子不可兼容0 。那么，我们只能采取一个更加复杂的方案：
&lt;/p&gt;
$$
\lceil( \frac{x}{ (|x|+1)} )\rceil -  \lceil(\frac {-x}{(|x|+1)} )\rceil
$$&lt;p&gt;
不过，在确认输入值 ≠0 的情况下，可以采用第一种方案。&lt;/p&gt;
&lt;h2 id=&#34;提取小数&#34;&gt;提取小数
&lt;/h2&gt;&lt;p&gt;提取小数可以用这两个简单的公式。同时，如果想表达是否“存在小数”，则进行向上取整即可：
&lt;/p&gt;
$$
x-\lfloor x \rfloor \\ mod(x,1)
$$&lt;h2 id=&#34;非运算&#34;&gt;非运算
&lt;/h2&gt;&lt;p&gt;1和-1的非运算再简单不过。我们考虑1和0的非运算：(两式效果相同)
&lt;/p&gt;
$$
|x-1| \\ -(x-1)
$$&lt;h2 id=&#34;与运算&#34;&gt;与运算
&lt;/h2&gt;&lt;p&gt;我们同样有多种方法可以实现该效果：
&lt;/p&gt;
$$
\lfloor\frac{x_1+x_2}{2}\rfloor  \\  x1\times x2
$$&lt;h2 id=&#34;或运算&#34;&gt;或运算
&lt;/h2&gt;&lt;p&gt;我们可以按照逻辑门的角度考虑：非（（非1）与（非2））即或。或者，我们可以用向上取整：
&lt;/p&gt;
$$
\lceil\frac{x_1+x_2}{2}\rceil
$$&lt;p&gt;
其实，拥有了以上三种门之后我们可以构筑出更多东西。在此并不一一列举，不过我们可以尝试构筑一下异或：&lt;/p&gt;
&lt;h2 id=&#34;异或运算&#34;&gt;异或运算
&lt;/h2&gt;&lt;p&gt;我们采用这个逻辑：（1 与 非2）或 （非1 与 2）：
&lt;/p&gt;
$$
\lceil\frac{[(x1\times-(x2-1))+(x2\times-(x1-1))]}{2}\rceil
$$&lt;h2 id=&#34;奇偶切割&#34;&gt;奇偶切割
&lt;/h2&gt;&lt;p&gt;我们可以通过以下两种方式将奇数部分和偶数部分切割。其中，前一种方案采取的是&lt;code&gt;1/-1&lt;/code&gt;编码，后一种采取的是&lt;code&gt;0,1&lt;/code&gt;编码：
&lt;/p&gt;
$$
(-1)^{\lfloor x\rfloor+1}  \\  mod(\lceil x\rceil,2)
$$&lt;h2 id=&#34;周期性取值&#34;&gt;周期性取值
&lt;/h2&gt;&lt;p&gt;用于在满足&lt;strong&gt;周期n&lt;/strong&gt;时取到&lt;strong&gt;值k&lt;/strong&gt;:（可以做成周期性添值或者乘值）
&lt;/p&gt;
$$
k|[mod(\lceil x \rceil,n)]-1|
$$&lt;h2 id=&#34;判断大小&#34;&gt;判断大小
&lt;/h2&gt;&lt;p&gt;判断x是否大于（或小于）某个数k，可以直接将x与k相减，再通过提取符号观察正负即可：
&lt;/p&gt;
$$
\frac{(x-k)}{|(x-k)|}(x≠0) \\\\ \lceil( \frac{(x-k)}{ (|(x-k)|+1)} )\rceil -  \lceil(\frac {-(x-k)}{(|(x-k)|+1)} )\rceil
$$&lt;p&gt;
如果想要判断是否在一定范围内，判断两次然后用与运算即可。&lt;/p&gt;
&lt;h2 id=&#34;选择器&#34;&gt;选择器
&lt;/h2&gt;&lt;p&gt;选择器只要根据条件在两种值中选择一种即可，实现上也非常简单（条件为k，两种情况分别为x1 x2）：
&lt;/p&gt;
$$
k(x_1)-(k-1)(x_2)
$$&lt;h2 id=&#34;多重与多重或&#34;&gt;多重与&amp;amp;多重或
&lt;/h2&gt;&lt;p&gt;多重与和多重或只需要用连乘和连加即可：
&lt;/p&gt;
$$
\prod_{i=1}^{n} x_i  \\ \lceil\frac{1}{n}\sum_{i=1}^{n} x_i\rceil
$$&lt;h2 id=&#34;判断数值&#34;&gt;判断数值
&lt;/h2&gt;&lt;p&gt;要判断x是否等于某个特定的值（k），我们只需要将x-k带进符号判断公式中，并将-1设为1再取反即可：
&lt;/p&gt;
$$
(|\lceil( \frac{x-k}{ (|x-k|+1)} )\rceil -  \lceil(\frac {-(x-k)}{(|x-k|+1)} )\rceil|-1)
$$&lt;h2 id=&#34;区间二分&#34;&gt;区间二分
&lt;/h2&gt;&lt;p&gt;让x在每个区间k内，将前半段和后半段进行区分（返回值0,1）：
&lt;/p&gt;
$$
\lfloor\frac {mod(x,k)}{k}+\frac{1}{2}\rfloor
$$&lt;h1 id=&#34;四实战&#34;&gt;四、实战
&lt;/h1&gt;&lt;p&gt;我们现在可以来快速尝试将上述的内容运用到实战：&lt;/p&gt;
&lt;h2 id=&#34;尝试1relu线性整流函数&#34;&gt;尝试1：ReLU（线性整流函数）
&lt;/h2&gt;&lt;p&gt;RuLU函数的基础函数是：
&lt;/p&gt;
$$
\max(0,x)
$$&lt;p&gt;
我们能否使用上述的内容来完成Relu呢？我们只需要用一个判断函数，在x的前面加上系数：x&amp;gt;0的判断，并将-1转化成0即可（为了实现这个目的，加一再除以2再向下取整）。式子如下：
&lt;/p&gt;
$$
x(\lfloor\frac{\lceil( \frac{(x-k)}{ (|(x-k)|+1)} )\rceil -  \lceil(\frac {-(x-k)}{(|(x-k)|+1)} )\rceil+1\lfloor}{2})
$$&lt;p&gt;
不过，这种方案是直接套模块得到的，我们还有更简单的方案，不过要具体分析情况得到了：
&lt;/p&gt;
$$
\frac{(x + |x|)}{2}
$$&lt;h2 id=&#34;尝试2自定义函数&#34;&gt;尝试2：自定义函数
&lt;/h2&gt;&lt;h3 id=&#34;场景设定&#34;&gt;场景设定
&lt;/h3&gt;&lt;p&gt;假设电费按用量分段计费：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一阶梯&lt;/strong&gt;（0~100度）：每度0.5元&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二阶梯&lt;/strong&gt;（100~200度）：超出100度的部分每度0.8元&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三阶梯&lt;/strong&gt;（&amp;gt;200度）：超出200度的部分每度1.2元&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分步构造&#34;&gt;分步构造
&lt;/h3&gt;&lt;h4 id=&#34;1-阶梯区间检测&#34;&gt;1. 阶梯区间检测
&lt;/h4&gt;&lt;p&gt;我们需要三个逻辑信号（1表示属于该区间，0表示不属于）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;k₁&lt;/strong&gt;（第一阶梯）：x ∈ [0,100]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;k₂&lt;/strong&gt;（第二阶梯）：x ∈ (100,200]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;k₃&lt;/strong&gt;（第三阶梯）：x &amp;gt; 200&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;构造方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用&lt;strong&gt;符号差+取整&lt;/strong&gt;检测边界：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
$$
    k_1 = \lceil \frac{100 - x + |100 - x|}{2(100 - x + |100 - x|) + 1} \rceil - \lceil \frac{x - 100 + |x - 100|}{2(x - 100 + |x - 100|) + 1} \rceil + 1
    $$&lt;/li&gt;
&lt;li&gt;
$$
    k_2 = \text{类似方法检测 } (100,200]
    $$&lt;/li&gt;
&lt;li&gt;
$$
    k_3 = \lceil \frac{x - 200}{x - 200 + |x - 200| + 1} \rceil
    $$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-阶梯费用计算&#34;&gt;2. 阶梯费用计算
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;$$
   第一阶梯费用：0.5x \cdot k_1\\
  第二阶梯费用：[50 + 0.8(x-100)] \cdot k_2\\
  第三阶梯费用：[130 + 1.2(x-200)] \cdot k_3\\
  $$&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-组合输出&#34;&gt;3. 组合输出
&lt;/h4&gt;&lt;p&gt;总费用 = 第一阶梯费用 + 第二阶梯费用 + 第三阶梯费用
通过&lt;strong&gt;逻辑门&lt;/strong&gt;确保只有当前阶梯信号为1时生效：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\text{Cost}(x) = \ &amp;amp;
\frac{x}{2} \left( \left\lfloor \frac{A_1}{2A_1+1} \right\rfloor \left\lfloor \frac{B_1}{2B_1+1} \right\rfloor + 1 \right) \&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\ &amp;amp;
\left( 50 + \frac{4(x-100)}{5} \right) \left( \left\lfloor \frac{A_2}{2A_2+1} \right\rfloor - \left\lfloor \frac{B_2}{2B_2+1} \right\rfloor  k_1 + 1 \right) \&lt;/li&gt;
&lt;li&gt;\ &amp;amp;
\left( 130 + \frac{6(x-200)}{5} \right) \left\lceil \frac{x-200}{C+1} \right\rceil
\end{aligned}
$$&lt;/li&gt;
&lt;/ul&gt;
$$
\begin{aligned}
A_1 &amp;= 100 - x + |100 - x|, \quad B_1 = x - 100 + |x - 100| \\
A_2 &amp;= 200 - x + |200 - x|, \quad B_2 = x - 200 + |x - 200| \\
C &amp;= x - 200 + |x - 200|, \quad k_1 = \left\lfloor \frac{A_1}{2A_1+1} \right\rfloor - \left\lfloor \frac{B_1}{2B_1+1} \right\rfloor + 1
\end{aligned}
$$&lt;h1 id=&#34;五总结&#34;&gt;五、总结
&lt;/h1&gt;&lt;p&gt;这种方法看上去会将简单的函数大幅复杂化，最终得到一个尽管效果相同但式子复杂上许多，但成功消灭了括号和具体的“规则”的式子。同时，这种思维方式相当系统化和模块化，可以实现一种有趣的自由组装的效果，类似于程序一样。&lt;/p&gt;
&lt;p&gt;希望这种方法能够具备一定的参考价值！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>机器学习线性代数学习笔记</title>
        <link>https://SJTdreams.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Wed, 01 Jan 2025 00:00:00 +0000</pubDate>
        
        <guid>https://SJTdreams.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;img src="https://SJTdreams.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/title.png" alt="Featured image of post 机器学习线性代数学习笔记" /&gt;&lt;h1 id=&#34;机器学习-线性代数学习笔记&#34;&gt;机器学习 线性代数学习笔记
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇是在学习过程中写的，可能会存在疏漏，欢迎补充！&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“人工智能是我们人类正在从事的最为深刻的研究方向之一，甚至要比火与电还更加深刻。”&lt;/p&gt;
&lt;p&gt;​											——桑德尔·皮猜（Sundar Pichai）, 2020&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本人观看地址：https://www.bilibili.com/video/BV1Pg4y1X7Pa/?spm_id_from=333.337.search-card.all.click&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;1-数学基础在ai学习中的作用&#34;&gt;1. 数学基础在AI学习中的作用
&lt;/h1&gt;&lt;h2 id=&#34;11-数学基础在ai研究中的必要性&#34;&gt;1.1 数学基础在AI研究中的必要性
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;理论支撑&lt;/strong&gt;：存在大量的AI模型理论都依靠大量的数学基础。深度学习的原理上涉及到了大量的线性代数运算，如点积、矩阵乘法等。而微积分也在各种损失函数、计算梯度上运用广泛。例如训练神经网络的核心算法：反向传播，就涉及到了大量的微积分知识。大名鼎鼎的框架TensorFlow，直译就是“张量流动”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模型优化&lt;/strong&gt;：在AI模型的训练过程中，优化算法如梯度下降法需要用到微积分的知识。数学能够帮助我们分析和选择最佳的学习率，从而加速模型的收敛，提高模型性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据分析&lt;/strong&gt;：AI领域中的数据预处理、特征提取等步骤都涉及到统计学和概率论。这些数学工具帮助我们从数据中提取有价值的信息，为模型训练提供支持。例如，可用通过统计学识别异常值，处理缺失值等。而将数据标准化和归一化也涉及到数学。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;算法创新&lt;/strong&gt;：数学是推动AI算法创新的关键。许多新的AI算法，如卷积神经网络（CNN）和循环神经网络（RNN），都是基于数学理论的创新。CNN运用了数学上的互相关运算，而RNN的时间序列也是矩阵表示的，RNN的预测还涉及到了马尔科夫链(概率论)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-深度学习可能涉及到的数学内容&#34;&gt;1.2 深度学习可能涉及到的数学内容
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线性代数&lt;/strong&gt;：在线性代数中，矩阵和向量运算是构建和理解神经网络的基础。矩阵的乘法、转置、逆等操作在神经网络的前向传播和反向传播中扮演着核心角色。线性代数极大程度的简化了模型的表示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;概率论与数理统计&lt;/strong&gt;：评估、选择模型，数据处理，决策优化等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微积分&lt;/strong&gt;：涉及到梯度下降，反向传播与正向传播，处理损失函数，进行正则化，卷积操作，一些其他的优化算法（如牛顿法、拟牛顿法等）等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;信息论&lt;/strong&gt;：评估特征信息量，量化模型复杂度，数据压缩等。其中的交叉熵损失函数广泛运用于分类、目标检测和NLP（自然语言处理）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;与均方误差（MSE）相比，交叉熵损失函数在处理分类问题时通常更具优势，因为它直接衡量模型对于类别分布的拟合程度，而MSE则通过最小化预测值与真实值之间的平方差来评估模型性能，这在分类问题中可能不够直观&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-线性代数的核心概念&#34;&gt;2. 线性代数的核心概念
&lt;/h1&gt;&lt;h2 id=&#34;21-矩阵的定义与应用&#34;&gt;2.1 矩阵的定义与应用
&lt;/h2&gt;&lt;p&gt;矩阵是线性代数中的一个基本概念，由数排成的矩形阵列，常用于线性方程组的系数表示、线性变换等。矩阵可以在某种程度上视为一个用于存放方程系数的二维系统，并且可以通过保持奇异性的行操作化简成行阶梯形。矩阵的广泛应用是线性代数中的核心，以下是矩阵的一些关键应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线性方程组&lt;/strong&gt;：矩阵可以用来表示线性方程组，通过矩阵运算可以求解方程组的解（例如可以通过高斯消元法求解），这对于理解和设计AI算法中的优化问题至关重要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据表示&lt;/strong&gt;：在机器学习中，数据通常以矩阵的形式表示，其中每一行代表一个样本，每一列代表一个特征。这种表示方法便于算法处理和分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;变换&lt;/strong&gt;：矩阵可以表示线性变换，如图像处理中的旋转、缩放等操作，这些都是计算机视觉中的基础操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;神经网络&lt;/strong&gt;：在深度学习中，神经网络的权重和输入数据都以矩阵的形式存在，矩阵乘法是前向传播和反向传播中的基本操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22-单位矩阵与逆矩阵&#34;&gt;2.2 单位矩阵与逆矩阵
&lt;/h2&gt;&lt;p&gt;单位矩阵和逆矩阵是矩阵理论中的重要概念，它们在解决线性方程组和线性变换中扮演着关键角色。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;单位矩阵&lt;/strong&gt;：单位矩阵是一个方阵，其主对角线上的元素都是1，其余元素都是0。单位矩阵与任何向量执行点积，其结果等于该向量。对单位矩阵做线性变换得到的基向量不变，这是因为单位矩阵代表了线性变换中的“无操作”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;逆矩阵&lt;/strong&gt;：逆矩阵与原矩阵的乘积等于单位矩阵。逆矩阵可以通过解方程计算得到。非奇异的矩阵总是有逆的（可逆矩阵），而奇异的矩阵总是无逆的。奇异的方程的行列式必然为0，这就像是数字0没有逆元一样。互为逆矩阵的矩阵的行列式互为倒数。刚好1/0是未定义的，奇异的矩阵无逆矩阵。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$$
    det({A}^{-1})=\frac {1} {det(A)}
    $$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;23-向量的基本性质&#34;&gt;2.3 向量的基本性质
&lt;/h2&gt;&lt;p&gt;向量是线性代数中的另一个核心概念，核心要素包括方向和大小，可以视为指向某个坐标的箭头。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;范数&lt;/strong&gt;：向量的范数是衡量向量“长度”的一种方式。默认的L2范数是向量内所有数平方和的平方根，而曼哈顿距离（L1范数）是向量内所有数的绝对值之和。这些范数在不同的应用场景中有着不同的用途，如在优化问题中，选择合适的范数可以帮助我们得到不同的优化结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;正交性&lt;/strong&gt;：当两个向量是正交的时，这两个向量的点积为0。这个性质在机器学习中的特征选择和降维中非常重要，因为它可以帮助我们识别和消除特征之间的相关性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;投影&lt;/strong&gt;：两个向量成角度的向量的点积，等同于其中一个向量对另一个向量做投影得到的向量与另一个向量的点积。这说明可以用投影的正负确定点积的正负，一定程度上可以理解为，点积值为正的两个向量夹角必然小于90度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3-线性代数的深入理解&#34;&gt;3. 线性代数的深入理解
&lt;/h1&gt;&lt;h2 id=&#34;31-奇异性与非奇异性&#34;&gt;3.1 奇异性与非奇异性
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;奇异性定义&lt;/strong&gt;：简单而言，一个不具备冗余和矛盾信息的句子系统或方程组是非奇异的。非奇异方程组在一般情况下通常可解，而奇异方程在一般情况下通常不可解。这可以通过行列式法或秩判定法来判断。行列式法涉及将矩阵按照两个方向划分为数条对角线，若各自乘积之和相等则是奇异的。秩判定法则是看方阵的秩是否小于其阶数，若是，则矩阵是奇异的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据科学中的应用&lt;/strong&gt;：在数据科学中，奇异性与非奇异性的概念对于理解数据集的线性独立性非常重要。一个非奇异的数据矩阵意味着数据集中没有冗余的特征，这有助于避免在机器学习模型中出现过拟合现象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数值计算中的影响&lt;/strong&gt;：在数值计算中，奇异矩阵可能导致算法的不稳定和数值误差的放大。例如，在求解线性方程组或者进行矩阵求逆时，奇异矩阵可能会导致算法失败或者结果不准确。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;32-秩的概念及其重要性&#34;&gt;3.2 秩的概念及其重要性
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;秩是矩阵的一个基本属性，它描述了矩阵中线性无关的行或列的最大数量，反映了矩阵所包含的“有效”信息的多少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;秩的定义&lt;/strong&gt;：矩阵的秩是矩阵中线性无关的行（或列）向量的最大个数。它决定了线性方程组中独立方程的个数，进而影响方程组解的情况。秩的概念在信息论中也非常重要，因为它可以衡量矩阵信息量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;秩与数据压缩&lt;/strong&gt;：在数据压缩和降维领域，秩的概念被用来识别最重要的特征。通过降低数据矩阵的秩，我们可以去除不重要的噪声和冗余信息，从而实现数据的有效压缩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;秩与机器学习&lt;/strong&gt;：在机器学习中，秩的概念可以帮助我们理解模型的复杂度。例如，在主成分分析（PCA）中，我们通过选择前几个主成分来降低数据的维度，这些主成分的数目通常与数据矩阵的秩有关。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;秩与线性方程组&lt;/strong&gt;：在线性方程组中，系数矩阵的秩决定了方程组解的性质。如果系数矩阵的秩等于增广矩阵的秩且小于变量的数目，则方程组有无穷多解；如果秩等于变量的数目，则方程组有唯一解；如果秩小于变量的数目，则方程组无解。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-行阶梯形式与高斯消元法&#34;&gt;4. 行阶梯形式与高斯消元法
&lt;/h1&gt;&lt;h2 id=&#34;41-行阶梯形式的特点&#34;&gt;4.1 行阶梯形式的特点
&lt;/h2&gt;&lt;p&gt;行阶梯形式是线性代数中对矩阵进行化简的一种重要形式，它通过保持奇异性的行操作对矩阵进行化简。以下是行阶梯形式的一些关键特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主元位置&lt;/strong&gt;：每一行最左边的非0数被称为主元，主元数等于秩的值。每一行的主元必然位于上一行的右方，这保证了矩阵的上三角结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全零行&lt;/strong&gt;：矩阵的全零行只能出现在矩阵的下部，且如果出现了全零行，该矩阵是奇异的。这一点是判断矩阵是否奇异的重要依据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;化简过程&lt;/strong&gt;：通过将每个主元所在列的其他数字化为0得到的矩阵被称为简化行梯形式。这个过程有助于进一步简化矩阵，使其更易于处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;非奇异性判定&lt;/strong&gt;：当且仅当主元的数等于阶数的矩阵是非奇异的。这意味着，如果一个矩阵在其行阶梯形式中每一行和每一列都有一个主元，则该矩阵是非奇异的，反之则为奇异。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对角线特性&lt;/strong&gt;：在行阶梯形式中，主对角线以下的所有元素都是0，这使得矩阵的结构更加清晰，便于进行后续的计算和分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;42-高斯消元法的应用&#34;&gt;4.2 高斯消元法的应用
&lt;/h2&gt;&lt;p&gt;高斯消元法是一种用于求解线性方程组的算法，它通过行操作将增广矩阵转换为行阶梯形式或简化行阶梯形式，从而得出方程组的解。以下是高斯消元法的一些关键应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方程求解&lt;/strong&gt;：高斯消元法可以将线性方程组的系数矩阵和常数项矩阵合并为一个增广矩阵，然后通过行操作将其转换为行阶梯形式，从而求解方程组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;算法效率&lt;/strong&gt;：高斯消元法在数值计算中非常高效，尤其是对于大规模的线性方程组。它的效率在于能够逐步消去变量，减少计算量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数值稳定性&lt;/strong&gt;：高斯消元法在执行过程中可以通过部分选主元等策略来提高数值稳定性，减少计算过程中的舍入误差。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;矩阵求逆&lt;/strong&gt;：高斯消元法也可以用来求解矩阵的逆。通过将单位矩阵与原矩阵增广，然后执行高斯消元，可以得到原矩阵的逆矩阵。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线性代数的基础&lt;/strong&gt;：高斯消元法是理解线性代数中许多其他概念和算法的基础，如矩阵分解、LU分解等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;在AI中的应用&lt;/strong&gt;：在AI领域，高斯消元法可以用于求解优化问题中的线性方程组，如在支持向量机（SVM）的训练过程中求解拉格朗日乘子。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过对行阶梯形式和高斯消元法的深入理解，我们可以更好地掌握线性代数在解决实际问题中的应用，尤其是在AI领域的算法实现和数据分析中。&lt;/p&gt;
&lt;h1 id=&#34;5-线性代数中的运算&#34;&gt;5. 线性代数中的运算
&lt;/h1&gt;&lt;h2 id=&#34;51-向量运算&#34;&gt;5.1 向量运算
&lt;/h2&gt;&lt;p&gt;向量运算是线性代数中的基础，它们在AI领域的数据处理和特征工程中扮演着重要角色。以下是向量运算的一些关键点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;向量-向量加法&lt;/strong&gt;：向量加法可以通过平行四边形法则来理解，其结果向量的坐标是两个向量对应坐标的和。在实际计算中，向量加法是按元素相加的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;向量-向量减法&lt;/strong&gt;：向量减法可以视为求两个向量差的运算，结果向量的坐标是两个向量对应坐标的差。在实际计算中，向量减法是按元素相减的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;向量-标量乘法&lt;/strong&gt;：向量与标量的乘法是将向量的每个元素乘以该标量，结果向量的每个元素都是原向量对应元素与标量的乘积。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;向量-向量乘法（点积）&lt;/strong&gt;：两个向量的点积是对应元素乘积的和。点积的结果是一个标量，它具有几何意义，如计算两个向量之间的夹角和相似度。在AI中，点积常用于特征归一化和相似性度量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;转置&lt;/strong&gt;：向量的转置是将行向量转换为列向量，或将列向量转换为行向量。在矩阵运算中，转置操作常用于改变数据的布局以适应特定的计算需求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;52-矩阵运算&#34;&gt;5.2 矩阵运算
&lt;/h2&gt;&lt;p&gt;矩阵运算是线性代数中的核心，它们在AI算法的实现中至关重要。以下是矩阵运算的一些关键点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;矩阵-向量乘法&lt;/strong&gt;：矩阵与向量的乘法是将矩阵的每一行与向量进行点积操作，结果是一个向量。在神经网络中，这种运算用于实现前向传播和反向传播。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;转置&lt;/strong&gt;：矩阵的转置是将矩阵的行和列互换，即原矩阵的第i行第j列元素变成转置矩阵的第j行第i列元素。转置操作在AI中用于调整数据维度，如在图像处理和特征变换中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;矩阵-矩阵乘法&lt;/strong&gt;：矩阵乘法是通过第一个矩阵的每一行与第二个矩阵的每一列的点积来计算的。矩阵乘法在AI中用于实现复杂的变换，如卷积神经网络中的卷积操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;矩阵-矩阵乘法有一个&lt;u&gt;特性&lt;/u&gt;：两个矩阵相乘再计算行列式的值会等于这两个矩阵的行列式的积。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
$$
    det(AB)=det(A)⋅det(B)
    $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而因为奇异矩阵的行列式为0，因此&lt;u&gt;&lt;strong&gt;任何&lt;/strong&gt;&lt;/u&gt;矩阵与奇异矩阵相乘都会等于0。这一点也可以说明为什么奇异的矩阵没有逆元，因为单位矩阵是非奇异的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线性变换&lt;/strong&gt;：矩阵可以表示线性变换，这种变换将平面上的点映射到另一个点。在AI中，线性变换用于特征提取和数据降维，如主成分分析（PCA）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过对线性代数中的向量和矩阵运算的深入理解，我们可以更好地掌握这些运算在AI领域的应用，从而在算法设计和数据分析中做出更合理的决策。&lt;/p&gt;
&lt;h1 id=&#34;6-线性变换及其应用&#34;&gt;6. 线性变换及其应用
&lt;/h1&gt;&lt;h2 id=&#34;61-线性变换的定义&#34;&gt;6.1 线性变换的定义
&lt;/h2&gt;&lt;p&gt;线性变换是线性代数中的一个重要概念，它描述了一种特殊的函数，这种函数将向量空间中的元素映射到同一空间或另一个向量空间中的元素，同时保持向量加法和标量乘法的操作不变。具体来说，如果有一个函数 \( T \) 从向量空间 \( V \) 映射到向量空间 \( W \)，对于任意向量 \( \mathbf{u}, \mathbf{v} \in V \) 和任意标量 \( c \)，满足以下两个条件，则 \( T \) 是一个线性变换：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
$$
   T(\mathbf{u} + \mathbf{v}) = T(\mathbf{u}) + T(\mathbf{v})
   $$&lt;/li&gt;
&lt;li&gt;
$$
   T(c\mathbf{u}) = cT(\mathbf{u})
   $$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;线性变换在AI领域中的应用非常广泛，包括图像处理、语音识别、自然语言处理等。例如，在图像处理中，线性变换可以用于图像的旋转、缩放和剪切等操作；在自然语言处理中，线性变换可以用于词向量的转换和文本的特征提取。&lt;/p&gt;
&lt;h2 id=&#34;62-线性变换与基向量&#34;&gt;6.2 线性变换与基向量
&lt;/h2&gt;&lt;p&gt;基向量是定义向量空间的一个关键概念，它们是一组线性无关的向量，可以用来表示空间中的任何向量。在线性变换中，基向量扮演着至关重要的角色，因为线性变换可以看作是基向量在变换下的映射。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基向量的变换&lt;/strong&gt;：对于一个给定的线性变换 \( T \)，如果我们知道基向量在 \( T \) 下的像，那么我们就可以确定 \( T \) 对空间中任何向量的作用。这是因为空间中的任何向量都可以表示为基向量的线性组合，而 \( T \) 的线性保证了它对线性组合的作用可以通过对基向量的作用来确定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;矩阵表示&lt;/strong&gt;：在实际应用中，线性变换通常通过矩阵来表示。如果
&lt;/p&gt;
$$
  \{\mathbf{v}_1, \mathbf{v}_2, ..., \mathbf{v}_n\}
  $$&lt;p&gt;
是向量空间 \( V \) 的一组基，
&lt;/p&gt;
$$
  \{\mathbf{w}_1, \mathbf{w}_2, ..., \mathbf{w}_m\} 
  $$&lt;p&gt;
是向量空间 \( W \) 的一组基，那么线性变换 \( T \) 可以由一个
&lt;/p&gt;
$$
  m \times n
  $$&lt;p&gt;
矩阵 \( A \) 来表示，其中矩阵的列是基向量
&lt;/p&gt;
$$
  \mathbf{v}_i 
  $$&lt;p&gt;
在 \( T \) 下的像，以 \( W \) 的基向量表示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;维度与秩&lt;/strong&gt;：线性变换的秩，即变换后图像的维度，等于变换矩阵的秩。如果变换是非奇异的，那么秩等于基向量的数量，这意味着基向量在变换后仍然覆盖整个空间。如果变换是奇异的，那么秩小于基向量的数量，这意味着基向量在变换后覆盖的空间降维了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;行列式与体积变化&lt;/strong&gt;：对于非奇异的线性变换，行列式的绝对值表示变换后基向量形成的平行六面体的体积与变换前基向量形成的单位立方体体积的比率。如果行列式的值为零，则变换是奇异的，基向量在变换后形成的体积为零，即所有的基向量映射到了一个低维空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;面积特征&lt;/strong&gt;：线性变换对于单位基向量的变换后的图像的面积等于行列式的值的绝对值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当行列式为负时，线条会颠倒。某种程度上可以把这视为负面积值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
$$
    S = |\det(A)|
    $$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;63-离散动力系统&#34;&gt;6.3 离散动力系统
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;离散动力系统描述了系统状态在离散时间点上的变化。离散动力系统的状态更新是在一系列特定的时间间隔内进行的，这些时间间隔通常称为时间步长。其函数可表示为：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
$$
    x_{t+1} = f(x_t)
    $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特征值和特征向量在离散动力系统和连续动力系统中都有应用，它们是数值代数的核心内容。对于一个马尔可夫矩阵。可以通过当前的状态向量与概率矩阵点积得到目标概率。当反复执行过程直到趋向于稳定，就表示得到的是特征向量且特征值为1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个所有列向量的元素和的值为1且所有元素非负的方阵叫做马尔可夫矩阵。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过对线性变换和基向量的深入理解，我们可以更好地把握线性代数在AI领域的应用，从而在算法设计和数据分析中做出更合理的决策。线性变换提供了一种强大的工具，用于分析和处理高维数据，而基向量则为我们提供了一种直观的方式来理解和操作这些变换。&lt;/p&gt;
&lt;h1 id=&#34;7张成和基&#34;&gt;7.张成和基
&lt;/h1&gt;&lt;h2 id=&#34;71-张成的概念与基的概念&#34;&gt;7.1 张成的概念与基的概念
&lt;/h2&gt;&lt;p&gt;​	张成不仅帮助我们理解向量之间的线性关系，还为定义和研究线性空间的结构提供了基础。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;张成的概念&lt;/strong&gt;：张成是一定的向量能够通过一定数量的重复叠加所能达到的所有位置。具体来说，给定一个向量集合 &lt;em&gt;S&lt;/em&gt;=&lt;em&gt;{v1,v2,…,vn}&lt;/em&gt;，这个集合的张成（span）就是所有可以表示为这些向量的线性组合的向量的集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基的概念&lt;/strong&gt;：基是一个最小（向量数量）的张成集。只有线性独立的向量才能构成基。基的向量数等同于该空间数的维度。&lt;/p&gt;
&lt;h2 id=&#34;72-基的特点&#34;&gt;7.2 基的特点
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性无关性&lt;/strong&gt;：只有线性独立的向量才能构成基。线性独立指你无法通过同组的其他向量构成该向量。
&lt;ul&gt;
&lt;li&gt;关于线性独立与奇异性的联系：考虑一个 n*×&lt;em&gt;n 的方阵 A&lt;/em&gt;，其列向量为 {v1,v2,…,vn}。
&lt;ul&gt;
&lt;li&gt;如果 &lt;em&gt;A&lt;/em&gt; 的列向量是线性独立的，那么 &lt;em&gt;A&lt;/em&gt; 是非奇异的，即 &lt;em&gt;A&lt;/em&gt; 有逆矩阵。&lt;/li&gt;
&lt;li&gt;如果 &lt;em&gt;A&lt;/em&gt; 的列向量是线性相关的，那么 &lt;em&gt;A&lt;/em&gt; 是奇异的，即 &lt;em&gt;A&lt;/em&gt; 没有逆矩阵。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;张成性&lt;/strong&gt;：基中的向量可以线性组合生成整个向量空间中的任何向量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最小性&lt;/strong&gt;：基是包含在向量空间中的最小向量集合，它既线性无关又张成整个空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;唯一性&lt;/strong&gt;：对于给定的向量空间，基不是唯一的，但任何两个基都包含相同数量的向量，这个数量就是空间的维度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;73-特征基&#34;&gt;7.3 特征基
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过特征向量构成的基被称为特征基。对于一个用于线性变换的矩阵，如果存在某一个（组）向量，通过该矩阵线性变换后只是缩放或反转，而非拉伸和扭曲，则称该基为这个矩阵的特征向量。可以用公式这样表示，其中&lt;em&gt;&lt;strong&gt;A&lt;/strong&gt;&lt;/em&gt;是一个矩阵，&lt;em&gt;&lt;strong&gt;v&lt;/strong&gt;&lt;/em&gt;是一个向量，&lt;em&gt;&lt;strong&gt;λ&lt;/strong&gt;&lt;/em&gt;是一个标量：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
$$
    Av = \lambda v
    $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在以上的定义公式中，&lt;em&gt;&lt;strong&gt;λ&lt;/strong&gt;&lt;/em&gt; 被称为特征向量 &lt;em&gt;&lt;strong&gt;v&lt;/strong&gt;&lt;/em&gt;的特征值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以通过计算&lt;strong&gt;标量-向量乘法&lt;/strong&gt;来代替&lt;strong&gt;矩阵-向量乘法&lt;/strong&gt;，这有效的降低了计算量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;特征向量具体的计算过程及原理&#34;&gt;特征向量具体的计算过程及原理：
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;因为特征向量在矩阵上只是缩放，因此变换后与变换前是&lt;u&gt;线性相关&lt;/u&gt;的。设存在一个特殊的矩阵，其满足将单位向量放大&lt;em&gt;m&lt;/em&gt;倍：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
$$
      m = \begin{pmatrix} m &amp; 0 &amp; 0 \\ 0 &amp; m &amp; 0 \\ 0 &amp; 0 &amp; m \end{pmatrix}
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后，我们假设这个m在某一条轴上与我们的目标矩阵缩放尺度相同。因为其处处相等，我们可以知道，其差是一个奇异的矩阵。那么便有：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
$$
      det(A−λI)=0
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个方程被称为特征方程。解特征方程 ，得到特征值 &lt;code&gt;λ1,λ2,…,λn&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于每个特征值 λi，我们需要找到对应的特征向量 vi。特征向量是一个非零的向量，且满足：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
$$
      (A−λi*I)vi=0
      $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于每一个特征值vi，我们执行这个解方程操作。这个方程组可能有多个解，但任何非零解都可以作为特征向量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将特征向量归一化，方便使用。当解出来的特征值存在相同项时，&lt;em&gt;&lt;strong&gt;不一定&lt;/strong&gt;&lt;/em&gt;有特征基。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;8pca主成分分析&#34;&gt;8.&lt;em&gt;PCA&lt;/em&gt;（主成分分析）
&lt;/h1&gt;&lt;p&gt;​	&lt;strong&gt;PCA（主成分分析，Principal Component Analysis）&lt;strong&gt;是一种统计方法，它通过正交变换将一组可能相关的变量转换为一组线性无关的变量集，称为&lt;/strong&gt;&lt;u&gt;主成分&lt;/u&gt;&lt;/strong&gt;。PCA 通常用于降维，数据压缩，特征提取，以及在探索性数据分析中寻找数据中的模式。&lt;/p&gt;
&lt;h2 id=&#34;81-pca的作用&#34;&gt;8.1 PCA的作用
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;降维&lt;/strong&gt;：减少数据的维度，降低计算复杂性，同时保留最重要的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;去相关&lt;/strong&gt;：新的特征（主成分）是&lt;em&gt;线性无关&lt;/em&gt;的，这有助于消除原始数据中的多重共线性问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据压缩&lt;/strong&gt;：通过保留最重要的主成分，可以有效地压缩数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可视化&lt;/strong&gt;：在高维数据集中，PCA 可以帮助将数据投影到二维或三维空间，以便于可视化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;噪声过滤&lt;/strong&gt;：PCA 可以通过去除数据中的噪声来提高模型的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据预处理&lt;/strong&gt;：在许多机器学习算法中，PCA 可以作为数据预处理步骤，以提高算法的效率和准确性。&lt;/p&gt;
&lt;h2 id=&#34;82-pca的使用&#34;&gt;8.2 PCA的使用
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;PCA的使用过程可以分为 步。假设我们拥有数据集&lt;em&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/em&gt;，则需按如下步骤进行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.&lt;strong&gt;中心化&lt;/strong&gt;：将数据集中的每个特征减去其均值，使得新的数据集具有零均值。从视觉上看，这就像是将点移到了坐标轴中间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设我们有一个数据集X，其中包含n个样本和m个特征。中心化的过程可以表示为：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
$$
        \mu = \begin{pmatrix} \frac{1}{n} \sum_{i=1}^{n} X_{i1}\frac{1}{n} \sum_{i=1}^{n} X_{i2} \\ \vdots \\ \frac{1}{n} \sum_{i=1}^{n} X_{im} \end{pmatrix}
        $$&lt;/li&gt;
&lt;li&gt;
$$
        X_{\text{centered}} = X - \mu
        $$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.&lt;strong&gt;协方差矩阵&lt;/strong&gt;:计算中心化数据的协方差矩阵，以了解特征之间的关系。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;协方差&lt;/strong&gt;：协方差可以方便的度量数据与数据之间对于彼此的&lt;u&gt;变化趋势&lt;/u&gt;。公式表示如下。其中 &lt;em&gt;&lt;strong&gt;μ&lt;/strong&gt;&lt;/em&gt; 是&lt;em&gt;&lt;strong&gt;X，Y&lt;/strong&gt;&lt;/em&gt;的均值。&lt;em&gt;&lt;strong&gt;E&lt;/strong&gt;&lt;/em&gt;是期望值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$$
          Cov(X 
          i
          ​
           ,X 
          j
          ​
           )=E[(X 
          i
          ​
           −μ 
          i
          ​
           )(X 
          j
          ​
           −μ 
          j
          ​
           )]
          $$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方差&lt;/strong&gt;：方差可以方便的衡量数据在轴上的密集程度。方差定义为定义为该随机变量与其均值（期望值）之差的平方的期望值。公式表示如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$$
          Var(X)=E[(X−μ) 
          2
           ]
          $$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;u&gt;协方差&lt;/u&gt;和&lt;u&gt;方差&lt;/u&gt;来定义协方差矩阵，定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
$$
          \text{Cov}(x, y) = \frac{1}{n-1} \sum_{i=1}^{n} (x_i - \mu_x)(y_i - \mu_y)
          $$&lt;/li&gt;
&lt;li&gt;
$$
          C = \text{Cov}(X) = \begin{bmatrix}
          \text{Var}(X_1) &amp; \text{Cov}(X_1, X_2) &amp; \cdots &amp; \text{Cov}(X_1, X_n) \\
          \text{Cov}(X_2, X_1) &amp; \text{Var}(X_2) &amp; \cdots &amp; \text{Cov}(X_2, X_n) \\
          \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
          \text{Cov}(X_n, X_1) &amp; \text{Cov}(X_n, X_2) &amp; \cdots &amp; \text{Var}(X_n)
          \end{bmatrix}
          $$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.&lt;strong&gt;特征值分解&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在已经计算出协方差矩阵的前提下，找出协方差矩阵的特征值和特征向量（被称为主成分）。因为协方差矩阵的转置不变的特点，所以特征向量必然正交。
&lt;ul&gt;
&lt;li&gt;特征值和特征向量计算的过程在前面有涉及。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.&lt;strong&gt;选择主成分&lt;/strong&gt;：根据特征值的大小选择最重要的特征向量，特征值越大，对应的特征向量越重要。这些特征向量构成了新的特征空间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据我们要的目标空间的维度，选择对应数量的特征向量。优先选择特征值大的特征向量作为投影对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.&lt;strong&gt;转换数据&lt;/strong&gt;：将数据&lt;strong&gt;投影&lt;/strong&gt;到对应的空间上，完成PCA。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;投影&lt;/strong&gt;的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;乘以目标空间的张成向量可以投影到目标空间上，而除以目标空间张量的范数可以避免发生延展。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
$$
          A_P = A \frac{v}{\|v\|_2}
          $$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;83-pca的局限性&#34;&gt;8.3 PCA的局限性
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性假设&lt;/strong&gt;：PCA 假设数据的主成分是线性的，对于非线性结构可能不适用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对异常值敏感&lt;/strong&gt;：PCA 对异常值非常敏感，异常值可能会对主成分产生较大影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9-总结&#34;&gt;9. 总结
&lt;/h1&gt;&lt;p&gt;线性代数作为数学的一个重要分支，在人工智能（AI）领域的应用至关重要。从基础的矩阵运算到复杂的线性变换，线性代数的概念和工具为AI算法的开发和优化提供了坚实的理论基础和计算框架。&lt;/p&gt;
&lt;h2 id=&#34;71-线性代数的核心作用&#34;&gt;7.1 线性代数的核心作用
&lt;/h2&gt;&lt;p&gt;线性代数的核心作用体现在以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;理论基础&lt;/strong&gt;：线性代数为AI算法提供了理论支撑，使得算法的实现成为可能。例如，神经网络中的权重更新和反向传播算法依赖于矩阵和向量的运算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据处理&lt;/strong&gt;：在AI中，数据通常以矩阵的形式表示，线性代数提供了处理和分析这些数据的有效工具，如特征提取和降维。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模型优化&lt;/strong&gt;：线性代数在模型优化中扮演着关键角色，尤其是在优化算法中，如梯度下降法，需要用到微积分和线性代数的知识。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;算法创新&lt;/strong&gt;：许多新的AI算法，如卷积神经网络（CNN）和循环神经网络（RNN），都是基于线性代数的理论创新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;72-线性代数的实际应用&#34;&gt;7.2 线性代数的实际应用
&lt;/h2&gt;&lt;p&gt;线性代数的实际应用包括但不限于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;图像处理&lt;/strong&gt;：在计算机视觉中，线性变换用于图像的旋转、缩放和剪切等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自然语言处理&lt;/strong&gt;：在线性代数的帮助下，可以实现词向量的转换和文本的特征提取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优化问题&lt;/strong&gt;：在线性代数的支持下，可以求解优化问题中的线性方程组，如在支持向量机（SVM）的训练过程中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;特征工程&lt;/strong&gt;：线性代数提供了特征归一化和相似性度量的工具，这对于特征选择和降维非常重要。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;[NOTE]&lt;/p&gt;
&lt;p&gt;本篇存在一定AI辅助&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
</description>
        </item>
        
    </channel>
</rss>
